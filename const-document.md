# 8 常量

* 预处理器只做些文本替代，它既没有类型检查概念，也没有类型检查功能，所以预处理器的值替代会产生一些微小的问题，这些问题在c++中可以通过使用const值而避免

* 当定义一个const的时候必须赋一个值给它，除非使用extern作出了清楚的说明：

  ​	` extern const int bufsize;`	

* 通常c++编译器并不为const创建存储空间，相反它把这个定义保存在它的符号表里。但是，上面的extern强制进行了存储空间分配

* 由于编译器不能完全避免为const分配内存，所以const的定义必须默认内部连接，即连接仅在特定的编译单元内；否则，由于众多的const在多个cpp文件内分配存储，容易引起连接错误

* const可以用于集合，在这种情况下，const意味着“不能改变的一块存储空间”。然而，不能在编译期间使用它的值，因为编译期间不需要知道存储的内容：

  ​	``` const int i[] = {1, 2, 3, 4};``` 

  ​	```//! float f[i[3]];	//Illegal``` 

* c中const的意思是“一个不能被改变的普通变量”，const常量总是占用存储而且它的名字是全局符。这样，c编译器不能把const看成一个编译期间的常量。

* c默认const是外部连接的，c++默认const是内部连接的。

* 可以把一个非const的对象的地址赋给一个 const指针，因为也许有时不想改变某些可以改变的东西。然而，不能把一个const对象的地址赋给一个非const指针，因为这样做可能通过被赋值的指针改变这个对象的值。当然，能够用类型转换强制进行这样的赋值。

* 若函数参数是按值传递的，则可用指定参数是const的，如：

  ```c++
  	void f1(const int i){

  		i++;		//Illegal -- compile-time error

  	}
  ```

  在函数里，const有这样的意义：参数不能被改变。所以它是函数创建者的工具，而不是函数调用者的工具。

* 对返回值来讲，存在一个类似的道理，即如果一个函数的返回值是一个常量：

  ​	` const int g();` 

  这就约定了函数框架里的原变量不会被修改。另外。因为是按值返回的，所以这个变量被制成副本，使得初值不会被返回值修改。这使得按值返回const没有意义：

  ```c++
  	int f3() {return 1;}

  	const int f4(){return 1;}
  ```


  	int main(){

  		const int j = f3();	//works fine

  		int k = f4();	//but this works fine too!

  	} 
  ```

  对于内部类型来说，按值返回的是否是一个const，是无关紧要的，所以按值返回一个内部类型时，应该去掉const，从而不使客户程序员混淆。

* 当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为const时，那么这个函数的返回值不能是一个左值（即它不能被赋值，也不能被修改）。例如：

  ```c++
  	class X{

  		int i;

  	public:

  		X(int ii=0);

  		void modify();

  	};

  	X::X(int ii){ i = ii; }

  	void X::modify() {i++;}

  	X f5(){ return X(); }

  	const X f6(){ return X(); }

  	void f7(X& x){

  		x.modify();

  	}

  	int main(){

  		f5() = X(1);

  		f5().modify();

  		//! f7(f5());	//cause warning
  		// cause compile-time errors:
        	//! f6() = X(1)
        	//! f6().modify();
        	//! f7(f6());
  	}

  ```

  因此，当按值返回一个对象时，如果不让这个对象作为一个左值使用，则使用const很重要。

  当按值返回一个内部类型时，const没有意义的原因是：编译器已经不让它成为一个左值。仅当按值返回用户自定义的类型对象时，才会出现上述问题。

* 通常接触不到临时对象，改变临时量是错误的，因为这些信息应该是不可得的。编译器使所有的临时量自动地成为const，这样当程序员犯那样的错误时，会向他发出错误警告。

  ` f7(f5());` 

  中，编译器必须产生一个临时对象来保存f5()的返回值，使得它能够传递给f7()。如果f7()的参数是按值传递的话，它能很好的工作，然后在f7()中形成那个临时量的副本，不会对临时量X产生任何影响。但是，如果f7()的参数是按引用传递的，这意味着它取临时对象X的地址，因为f7()所带的参数不是按const引用传递的，所以它允许对临时对象X进行修改。

* 把一个临时对象传递给接受const引用的函数是可能的，但不能把一个临时对象传递给接受指针的函数--对于指针，它必须明确地接受地址。所以，按引用传递会产生一个从来不会在c中出现的新的情形：一个总是const的临时变量，它的地址可以被传递给一个函数。这就是为什么临时变量按引用传递给一个函数时，这个函数的参数必须是const引用的原因。

* 可以使整个对象作为const，但是，要保持类对象为常量却比较复杂。编译器能保证一个内部类型为常量，但不能控制类中的复杂性。为了保证一个类对象为常量，引进了const成员函数：const成员函数只能对于const对象调用

* 初始化const数据成员时，必须在进入函数体前被初始化。

* 必须在static const定义的地方对它进行初始化

* 如果声明一个成员函数为const，则等于告诉编译器该成员函数可以为一个const对象所调用。一个没有被明确声明为const的成员函数被看成是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。然而，不能到此为止。仅仅声明一个函数在类定义里是const的，还不能保证成员函数按声明的方式去做，所以编译器强迫程序员在定义函数时要重申const说明。（const已成为函数识别符的一部分，所以编译器和连接程序都要检查const）

* 一个const成员函数，不管它试图以何种方式改变成员或者调用另一个非const成员函数，编译器都把它标记为一个错误。

* 一个const成员函数调用const和非const对象是安全的

* 构造函数和析构函数都不是const成员函数，因为他们在初始化和清除时，总是对对象作些修改

* 按为const意思是对象中的每个字节都是固定的，所以对象的每个位映像从不改变。按逻辑const意思是，虽然整个对象从概念上讲是不变的，但是可以以成员为单位改变。当编译器被告知一个对象是const对象时，它将绝对保护这个对象的常量性。

* 有两种由内部const成员函数改变数据成员的方法

  * 第一种方法已成为过去，称为”强制转换常量性“。它以相当奇怪的方式执行。取this并把强制转换成指向当前类型对象的指针。看来this已经是所需的指针，但是，在const成员函数内部，它实际上是一个const指针，所以，还应把它强制转换成一个普通指针，这样就可以在那个运算中去掉常量性。下面是一个例子：

  ```c++
  class Y{
    int i;
    public:
    	Y();
    	void f() const;
  };
  Y::Y(){i=0;}
  void Y::f()const{
    //! i++;	//error -- const member function
    ((Y*)this)->i++;	//ok: cast away const-ness
    // better: use c++ explicit cast syntax:
    (const_cast<Y*>(this))->i++;
  }
  int main(){
    const Y yy;
    yy.f();
  }
  ```

  这种方法是可行的，在过去的程序代码中可以看到这种用法，但这不是首选的技术。问题是：常量性的缺乏影藏在成员函数的定义中。

  * 第二种方法，应当在类声明里使用关键字mutable，以指定一个特定的数据成员可以在一个const对象里被改变。

  ```c++
  class Z{
    int i;
    mutable int j;
    public:
    	Z();
    	void f() const;
  };
  Z::Z()：i(0), j(0){}
  void Z::f() const{
    //! i++;	//error -- const member function
    	j++;	//ok: mutable
  }
  int main()
  {
    const Z zz;
    zz.f();	//actually changes it
  }
  ```

* volatile的语法与const是一样的，但是volatile的意思是”在编译器认识的范围外，这个数据可以被改变“。不知何故，环境正在改变数据（可能是通过多任务、多线程或者中断处理），所以，volatile告诉编译器不要擅自作出有关该数据的任何假定，优化期间尤其如此。

* 程序员可以建立const volatile对象，这个对象不能被客户程序员改变，但可以通过外部的代理程序改变。

